<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Tests</title>
  <link rel="stylesheet" href="../css/main.css">
</head>
<body>

<br>
<h2>Tests</h2>

<h3>Position und Zoom</h3>
<ol>
<li><a href="../plot.htm?x-1;;P(1.0,0.0)">um 1</a>
<li><a href="../plot.htm?x/1000;;scale(1,0.001),P(0,0.004)"
  >Position nach Teilen</a>
</ol>

<h3>Frequente Schwingungen und hoher Anstieg</h3>
<ol>
<li><a href="../plot.htm?sin(100/x)"
  >sin(100/x)</a>
<li><a href="../plot.htm?1/sin(100/x)"
  >1/sin(100/x)</a>
<li><a href="../plot.htm?1/sin(x%5e3)"
  >1/sin(x<sup>3</sup>)</a>
</ol>

<h3>Funktionsdefinition</h3>
<ol>
<li><a href="../plot.htm?f(x);%20f:=x.x%5e2"
  >Lambda-Abstraktion</a>
<li><a href="../plot.htm?f(x,2);%20f:=(x,y).x%5ey"
  >Lambda-Abstraktion mit zwei Argumenten</a>
<li><a href="../plot.htm?f(x)(2);%20f:=x.(y.x%5ey)"
  >Lambda-Abstraktion mit Currying</a>
</ol>

<h3>Vektoriell</h3>
<ol>
<li><a href="../plot.htm?abs(%5bx,y%5d)=1"
  >Kreis</a>
<li><a href="../plot.htm?f%27(t);%20f(t):=(cos(7t)/2+1)*%5bcos(t),sin(t)%5d"
  >Differentialrechnung</a>
</ol>

<h3>Quadratur</h3>
<ol>
<li><a href="../plot.htm?f(x);%20f(x):=1/cosh(10(x-0.2))%5e2+1/cosh(100(x-0.4))%5e4+1/cosh(1000(x-0.6))%5e6;%20calc(%22bench(f-%3eint(0,1,f,100),f)%22);;scale(0.05,0.2),P(0.347,0.604)"
  >Test-Integral (Cranley and Patterson, 1971)</a><br>&mdash; korrekter Wert: 0.21080273550054927737564&hellip;
<li><a href="../plot.htm?f(x);%20f(x):=sin(x+e%5ex);%20calc(%22bench(f-%3eint(0,8,f,10),f)%22)"
  >Test-Integral (Rump, 2010)</a><br>&mdash; korrekter Wert: 0.34740017265&hellip;
<li><a href="../plot.htm?f(x);%20f(x):=(e%5ex-floor(e%5ex))*sin(x+e%5ex);%20calc(%22bench(f-%3eint(0,8,f,10),f)%22)"
  >Test-Integral</a><br>&mdash; korrekter Wert: 0.098651704478365206119658&hellip;
</ol>

<h3>Bug-Archiv</h3>
<p><b>Bug, Herbst 2020.</b> Eine beliebige Funktion mit
Namen <code>I</code>, bspw.
<code>I(x):=x</code> hatte <code>2I(x)=[]</code> für jede Zahl
<code>x</code> zur Folge. Ursache: <code>I(n)</code> war die
n&times;n-Einheitsmatrix und in <code>id_type_table</code>
&ndash; für <i>Bezeichner-Typisierungstabelle</i> &ndash;
gelistet. Das Problem trat bei Redefinition von allen
darin gelisteten Funktionen auf. Bei der Typinferenz wurde nun nicht
überprüft, ob die Bedeutung von <code>I</code> durch Definition
einer globalen Variable überschrieben wurde. Diese Prüfung ist
auch nicht ohne weiteres möglich. Daraus ergibt sich, dass die
Typisierung streng genommen Teil des Tabelleneintrags in der
Bezeichnertabelle sein sollte. Dann würde der gesamte Eintrag
bei Redefinition automatisch überschrieben, das Problem träte
per se nicht auf.

<p><b>Behebung.</b> Fürs Erste sollte <code>I</code> in
<code>idm</code> umbenannt werden. Die anderen Einträge in
<code>id_type_table</code> waren
<code>unit, nabla, rot, diag, tp, expm, jacobi</code>, also
weniger problematisch.

</body>
</html>

